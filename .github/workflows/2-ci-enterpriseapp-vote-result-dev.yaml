###############################################################################
# Opsera 11-Stage CI/CD Pipeline: RESULT Service (dev)
# App: enterpriseapp-vote | Service: result | Env: dev
###############################################################################
name: "CI/CD - enterpriseapp-vote - result - dev"

on:
  push:
    branches:
      - main
    paths:
      - "result/**"
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

env:
  APP_NAME: enterpriseapp-vote
  SERVICE_NAME: result
  TENANT: opsera
  ENV: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  NAMESPACE: opsera-enterpriseapp-vote-dev
  DOMAIN: agent.opsera.dev
  ARGOCD_APP: opsera-enterpriseapp-vote-dev
  MANIFEST_PATH: .opsera-enterpriseapp-vote/k8s/overlays/dev
  ARGOCD_PATH: .opsera-enterpriseapp-vote/argocd/dev
  DOCKERFILE_PATH: result/Dockerfile
  BUILD_CONTEXT: result/
  ECR_REPO: enterpriseapp-vote-result
  PLACEHOLDER_NAME: PLACEHOLDER_ECR_URI_RESULT

jobs:
  # ===========================================================================
  # Stage 1: Security Scan (Gitleaks)
  # ===========================================================================
  security-scan:
    name: "Stage 1 - Security Scan (Gitleaks)"
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        uses: zricethezav/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ===========================================================================
  # Stage 2: Build Image
  # ===========================================================================
  build-image:
    name: "Stage 2 - Build Image"
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        id: build
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

          docker build \
            --tag "${{ env.SERVICE_NAME }}:${IMAGE_TAG}" \
            --file "${{ env.DOCKERFILE_PATH }}" \
            "${{ env.BUILD_CONTEXT }}"

          docker save "${{ env.SERVICE_NAME }}:${IMAGE_TAG}" \
            -o "${{ env.SERVICE_NAME }}-${IMAGE_TAG}.tar"

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ env.SERVICE_NAME }}
          path: "${{ env.SERVICE_NAME }}-${{ steps.build.outputs.image_tag }}.tar"
          retention-days: 1

  # ===========================================================================
  # Stage 3: Grype Scan
  # ===========================================================================
  grype-scan:
    name: "Stage 3 - Grype Vulnerability Scan"
    runs-on: ubuntu-latest
    needs: build-image
    continue-on-error: true
    steps:
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ env.SERVICE_NAME }}

      - name: Load Docker image
        run: |
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          docker load -i "${{ env.SERVICE_NAME }}-${IMAGE_TAG}.tar"

      - name: Run Grype scan
        uses: anchore/scan-action@v3
        id: grype
        with:
          image: "${{ env.SERVICE_NAME }}:${{ needs.build-image.outputs.image_tag }}"
          severity-cutoff: high
          fail-build: false
          output-format: sarif

      - name: Upload SARIF report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: grype-sarif-${{ env.SERVICE_NAME }}
          path: ${{ steps.grype.outputs.sarif }}
          retention-days: 30

  # ===========================================================================
  # Stage 4: Push to ECR
  # ===========================================================================
  push-to-ecr:
    name: "Stage 4 - Push to ECR"
    runs-on: ubuntu-latest
    needs: [build-image, grype-scan]
    if: always() && needs.build-image.result == 'success'
    outputs:
      ecr_uri: ${{ steps.push.outputs.ecr_uri }}
      full_image: ${{ steps.push.outputs.full_image }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ env.SERVICE_NAME }}

      - name: Load, tag, and push to ECR
        id: push
        run: |
          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPO }}"

          echo "ecr_uri=${ECR_URI}" >> "$GITHUB_OUTPUT"
          echo "full_image=${ECR_URI}:${IMAGE_TAG}" >> "$GITHUB_OUTPUT"

          docker load -i "${{ env.SERVICE_NAME }}-${IMAGE_TAG}.tar"
          docker tag "${{ env.SERVICE_NAME }}:${IMAGE_TAG}" "${ECR_URI}:${IMAGE_TAG}"
          docker push "${ECR_URI}:${IMAGE_TAG}"

          echo "Pushed: ${ECR_URI}:${IMAGE_TAG}"

  # ===========================================================================
  # Stage 5: Refresh ECR Secret (SPOKE cluster)
  # ===========================================================================
  refresh-ecr-secret:
    name: "Stage 5 - Refresh ECR Pull Secret"
    runs-on: ubuntu-latest
    needs: push-to-ecr
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Switch to SPOKE cluster and refresh ECR secret
        run: |
          aws eks update-kubeconfig --name "${{ env.SPOKE_CLUSTER }}" --region "${{ env.AWS_REGION }}"

          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_REGISTRY="${AWS_ACCOUNT_ID}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          ECR_TOKEN=$(aws ecr get-login-password --region "${{ env.AWS_REGION }}")

          kubectl create secret docker-registry ecr-pull-secret \
            --docker-server="${ECR_REGISTRY}" \
            --docker-username=AWS \
            --docker-password="${ECR_TOKEN}" \
            -n "${{ env.NAMESPACE }}" \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "ECR pull secret refreshed in namespace ${{ env.NAMESPACE }}"

  # ===========================================================================
  # Stage 6: Update Manifests
  # ===========================================================================
  update-manifests:
    name: "Stage 6 - Update K8s Manifests"
    runs-on: ubuntu-latest
    needs: [build-image, push-to-ecr, refresh-ecr-secret]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          fetch-depth: 0

      - name: Update kustomization.yaml for result
        run: |
          git pull origin main

          IMAGE_TAG="${{ needs.build-image.outputs.image_tag }}"
          ECR_URI="${{ needs.push-to-ecr.outputs.ecr_uri }}"

          cd "${{ env.MANIFEST_PATH }}"

          # Use yq to update only the result image entry
          yq e '(.images[] | select(.name == "${{ env.PLACEHOLDER_NAME }}")).newName = "'"${ECR_URI}"'"' -i kustomization.yaml
          yq e '(.images[] | select(.name == "${{ env.PLACEHOLDER_NAME }}")).newTag = "'"${IMAGE_TAG}"'"' -i kustomization.yaml

          cd "${GITHUB_WORKSPACE}"

          # Only commit if there are actual changes
          if git diff --quiet; then
            echo "No changes to commit"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add "${{ env.MANIFEST_PATH }}/kustomization.yaml"
            git commit -m "[skip ci] Update ${{ env.SERVICE_NAME }} image to ${IMAGE_TAG}"
            git push origin main
          fi

  # ===========================================================================
  # Stage 7: Create ArgoCD Application (HUB cluster)
  # ===========================================================================
  create-argocd-app:
    name: "Stage 7 - Create ArgoCD Application"
    runs-on: ubuntu-latest
    needs: update-manifests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Switch to HUB cluster and apply ArgoCD application
        run: |
          aws eks update-kubeconfig --name "${{ env.HUB_CLUSTER }}" --region "${{ env.AWS_REGION }}"
          kubectl apply -f "${{ env.ARGOCD_PATH }}/application.yaml"
          echo "ArgoCD application applied (idempotent)"

  # ===========================================================================
  # Stage 8: ArgoCD Refresh (HUB cluster)
  # ===========================================================================
  argocd-refresh:
    name: "Stage 8 - ArgoCD Hard Refresh"
    runs-on: ubuntu-latest
    needs: create-argocd-app
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Annotate ArgoCD app for hard refresh
        run: |
          aws eks update-kubeconfig --name "${{ env.HUB_CLUSTER }}" --region "${{ env.AWS_REGION }}"

          kubectl annotate application "${{ env.ARGOCD_APP }}" \
            -n argocd \
            argocd.argoproj.io/refresh=hard \
            --overwrite

          echo "ArgoCD hard refresh triggered for ${{ env.ARGOCD_APP }}"

  # ===========================================================================
  # Stage 9: ArgoCD Sync (HUB cluster)
  # ===========================================================================
  argocd-sync:
    name: "Stage 9 - ArgoCD Sync & Wait"
    runs-on: ubuntu-latest
    needs: argocd-refresh
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Wait for ArgoCD sync to complete
        run: |
          aws eks update-kubeconfig --name "${{ env.HUB_CLUSTER }}" --region "${{ env.AWS_REGION }}"

          # Debug: verify we can reach the hub cluster and the app exists
          echo "--- Verifying ArgoCD application access ---"
          kubectl get application "${{ env.ARGOCD_APP }}" -n argocd -o wide 2>&1 || true
          echo "---"

          echo "Waiting for ArgoCD auto-sync to complete..."
          for i in $(seq 1 60); do
            APP_JSON=$(kubectl get application.argoproj.io "${{ env.ARGOCD_APP }}" -n argocd -o json 2>/dev/null || echo "{}")
            HEALTH=$(echo "${APP_JSON}" | jq -r '.status.health.status // "Unknown"')
            SYNC=$(echo "${APP_JSON}" | jq -r '.status.sync.status // "Unknown"')

            echo "Iteration ${i}/60 - Health: ${HEALTH} | Sync: ${SYNC}"

            if [ "${HEALTH}" = "Healthy" ] && [ "${SYNC}" = "Synced" ]; then
              echo "Application is Healthy and Synced!"
              exit 0
            fi

            if [ "${HEALTH}" = "Degraded" ] && [ "${i}" -gt 30 ]; then
              echo "ERROR: Application is Degraded after 30 attempts."
              echo "${APP_JSON}" | jq '.status.conditions // []'
              exit 1
            fi

            sleep 5
          done

          echo "ERROR: Timed out waiting for sync (5 minutes)"
          kubectl get application.argoproj.io "${{ env.ARGOCD_APP }}" -n argocd -o yaml 2>&1 | tail -30 || true
          exit 1

  # ===========================================================================
  # Stage 10: Verify Deployment (SPOKE cluster)
  # ===========================================================================
  verify-deployment:
    name: "Stage 10 - Verify Deployment"
    runs-on: ubuntu-latest
    needs: argocd-sync
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify deployment on SPOKE cluster
        run: |
          aws eks update-kubeconfig --name "${{ env.SPOKE_CLUSTER }}" --region "${{ env.AWS_REGION }}"

          echo "=== Pods in namespace ${{ env.NAMESPACE }} ==="
          kubectl get pods -n "${{ env.NAMESPACE }}"

          echo ""
          echo "=== Rollout status for ${{ env.SERVICE_NAME }} ==="
          kubectl rollout status deployment/${{ env.SERVICE_NAME }} \
            -n "${{ env.NAMESPACE }}" \
            --timeout=120s

          echo ""
          echo "=== Health check for ${{ env.SERVICE_NAME }} ==="
          # Port-forward and curl health check for result service (port 80)
          kubectl port-forward \
            svc/${{ env.SERVICE_NAME }} 8080:80 \
            -n "${{ env.NAMESPACE }}" &
          PF_PID=$!
          sleep 5

          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/ || echo "000")
          kill $PF_PID 2>/dev/null || true

          if [ "${HTTP_STATUS}" -ge 200 ] && [ "${HTTP_STATUS}" -lt 400 ]; then
            echo "Health check PASSED (HTTP ${HTTP_STATUS})"
          else
            echo "WARNING: Health check returned HTTP ${HTTP_STATUS}"
          fi

  # ===========================================================================
  # Stage 11: Deployment Landscape
  # ===========================================================================
  deployment-landscape:
    name: "Stage 11 - Deployment Landscape"
    runs-on: ubuntu-latest
    needs: verify-deployment
    steps:
      - name: Print deployment summary
        run: |
          echo "============================================================"
          echo "  DEPLOYMENT LANDSCAPE SUMMARY"
          echo "============================================================"
          echo "  App Name      : ${{ env.APP_NAME }}"
          echo "  Service       : ${{ env.SERVICE_NAME }}"
          echo "  Environment   : ${{ env.ENV }}"
          echo "  Image Tag     : ${{ needs.build-image.outputs.image_tag }}"
          echo "  ECR Repo      : ${{ env.ECR_REPO }}"
          echo "  Namespace     : ${{ env.NAMESPACE }}"
          echo "  ArgoCD App    : ${{ env.ARGOCD_APP }}"
          echo "  Hub Cluster   : ${{ env.HUB_CLUSTER }}"
          echo "  Spoke Cluster : ${{ env.SPOKE_CLUSTER }}"
          echo "  Domain        : ${{ env.DOMAIN }}"
          echo "  Status        : DEPLOYED"
          echo "  Timestamp     : $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "============================================================"
